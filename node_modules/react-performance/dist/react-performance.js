import { Component, createElement } from 'react';
import { connect } from 'react-redux';
import { batchedSubscribe } from 'redux-batched-subscribe';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

//      

var getIdentifier = function getIdentifier(_ref) {
  var element = _ref.element,
      getId = _ref.getId;

  // $FlowExpectedError
  var debugId = element._reactInternalFiber._debugID;
  var elementId = getElementId({ element: element, getId: getId });
  return (elementId || 'anonymous') + ' (' + debugId + ')';
};

var getElementId = function getElementId(_ref2) {
  var element = _ref2.element,
      getId = _ref2.getId;

  if (typeof getId !== 'string') {
    return getId(element.props);
  }
  if (!element.props.hasOwnProperty(getId)) {
    return getId;
  }
  return getId + '=' + element.props[getId];
};

var getChangeDetails = function getChangeDetails(_ref3) {
  var object = _ref3.object,
      prevObject = _ref3.prevObject;
  return Array.from(new Set([].concat(toConsumableArray(Object.keys(prevObject)), toConsumableArray(Object.keys(object))))).filter(function (key) {
    if (typeof prevObject[key] === 'function' && typeof object[key] === 'function') {
      return false;
    }
    return prevObject[key] !== object[key];
  }).map(function (key) {
    return {
      key: key,
      prevValue: prevObject[key],
      value: object[key]
    };
  });
};

//      

var isRecording = false;
var record = {};

var measure = function measure(_ref) {
  var getId = _ref.getId,
      Component$$1 = _ref.Component,
      _ref$isCollapsed = _ref.isCollapsed,
      isCollapsed = _ref$isCollapsed === undefined ? true : _ref$isCollapsed;

  if (!process || !process.env || process.env.NODE_ENV !== 'development') {
    return Component$$1;
  }

  var Measured = function (_React$Component) {
    inherits(Measured, _React$Component);

    function Measured() {
      var _ref2;

      var _temp, _this, _ret;

      classCallCheck(this, Measured);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = Measured.__proto__ || Object.getPrototypeOf(Measured)).call.apply(_ref2, [this].concat(args))), _this), _this.identifier = '<<unidentified>>', _this.recordIdentifier = '<<unidentified>>', _this.renderStartedAt = 0, _this.renderEndedAt = 0, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Measured, [{
      key: 'render',
      value: function render() {
        return createElement(Component$$1, this.props);
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        this.identifier = getIdentifier({ element: this, getId: getId });
        this.recordIdentifier = createRecordItem({ element: this, componentName: componentName });
        this.startTimer();
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.groupStart(true, 'Mounted %o', componentName);
        this.endTimer();
        this.groupEnd();
      }
    }, {
      key: 'componentWillUpdate',
      value: function componentWillUpdate() {
        this.startTimer();
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps, prevState) {
        var changeDetails = getChangeDetails({
          object: this.props,
          prevObject: prevProps
        });
        var hasChanges = !!changeDetails.length;
        this.groupStart(hasChanges, 'Rendered %o', componentName);
        this.endTimer();
        this.logChanges(changeDetails);
        this.groupEnd();
        recordUpdate({ hasChanges: hasChanges, element: this });
      }
    }, {
      key: 'getTimerText',
      value: function getTimerText() {
        return ['Identifier: ' + this.identifier, 'Render time'].join('\n');
      }
    }, {
      key: 'startTimer',
      value: function startTimer() {
        this.renderStartedAt = Date.now();
        var timerText = this.getTimerText();
        console.time(timerText);
        if (this.props._isProfilingPerf) {
          console.profile(timerText);
        }
      }
    }, {
      key: 'endTimer',
      value: function endTimer() {
        this.renderEndedAt = Date.now();
        console.timeEnd(this.getTimerText());
        if (this.props._isProfilingPerf) {
          console.profileEnd();
        }
      }
    }, {
      key: 'groupStart',
      value: function groupStart(hasChanges) {
        var _console2;

        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        if (hasChanges && isCollapsed) {
          var _console;

          (_console = console).groupCollapsed.apply(_console, args);
          return;
        }
        (_console2 = console).group.apply(_console2, args);
      }
    }, {
      key: 'groupEnd',
      value: function groupEnd() {
        console.groupEnd();
      }
    }, {
      key: 'logChanges',
      value: function logChanges(changeDetails) {
        if (!changeDetails.length) {
          console.log('ðŸš¨ %cWasted render %c(no changed props)', 'color: red', 'color: gray');
          return;
        }
        changeDetails.forEach(function (changeDetail) {
          console.log('Changed prop %o: %o â†’ %o', changeDetail.key, changeDetail.prevValue, changeDetail.value);
        });
      }
    }]);
    return Measured;
  }(Component);

  var componentName = Component$$1.displayName || Component$$1.name;
  Measured.displayName = 'Measured(' + componentName + ')';
  return Measured;
};

////////////
// RECORD //
////////////


var INITIAL_ITEM_KEYS = {
  'Wasted time (ms)': 0,
  'Wasted renders': 0,
  'Renders': 0
};

var createRecordItem = function createRecordItem(_ref3) {
  var element = _ref3.element,
      componentName = _ref3.componentName;

  // $FlowFixMe
  var owner = element._reactInternalFiber._debugOwner;
  var ownerName = owner !== null && typeof owner !== 'undefined' ? element._reactInternalFiber._debugOwner.type.name : "";
  var recordIdentifier = componentName + ': ' + element.identifier;
  record[recordIdentifier] = _extends({
    'Owner > component': ownerName + ' > ' + componentName
  }, INITIAL_ITEM_KEYS);
  return recordIdentifier;
};

var recordReset = function recordReset() {
  Object.keys(record).forEach(function (key) {
    record[key] = _extends({}, record[key], INITIAL_ITEM_KEYS);
  });
};

var recordUpdate = function recordUpdate(_ref4) {
  var hasChanges = _ref4.hasChanges,
      element = _ref4.element;

  if (!isRecording) {
    return;
  }
  record[element.recordIdentifier]['Renders'] += 1;
  if (!hasChanges) {
    record[element.recordIdentifier]['Wasted renders'] += 1;
    record[element.recordIdentifier]['Wasted time (ms)'] += element.renderEndedAt - element.renderStartedAt;
  }
};

var startRecording = function startRecording() {
  isRecording = true;
  recordReset();
};

var printRecording = function printRecording() {
  isRecording = false;
  console.table(record);
  recordReset();
};

//      

var connect$1 = function connect$$1(_ref) {
  var mapStateToProps = _ref.mapStateToProps,
      mapDispatchToProps = _ref.mapDispatchToProps,
      getId = _ref.getId,
      Component$$1 = _ref.Component,
      isCollapsed = _ref.isCollapsed;
  return connect(mapStateToProps, mapDispatchToProps)(measure({ getId: getId, Component: Component$$1, isCollapsed: isCollapsed }));
};

//      

var createNotifier = function createNotifier() {
  var notifyAnimationFrame = null;
  return batchedSubscribe(debounce({ wait: 5, method: function method(notify) {
      if (notifyAnimationFrame) {
        return;
      }
      notifyAnimationFrame = requestAnimationFrame(function () {
        notifyAnimationFrame = null;
        console.group('Notifying store updates');
        console.time('Store update render time');
        notify();
        console.timeEnd('Store update render time');
        console.groupEnd();
      });
    } }));
};

var debounce = function debounce(_ref) {
  var wait = _ref.wait,
      method = _ref.method;

  var timeout = void 0;
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    clearTimeout(timeout);
    timeout = setTimeout(function () {
      return method.apply(undefined, args);
    }, wait);
  };
};

//      

var index = {
  connect: connect$1,
  createNotifier: createNotifier,
  measure: measure,
  startRecording: startRecording,
  printRecording: printRecording
};

export { connect$1 as connect, createNotifier, measure, startRecording, printRecording };
export default index;
